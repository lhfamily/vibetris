<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>NEON TETRIS</title>
<style>
@import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap");

* {
    font-family: "Press Start 2P";
    touch-action: none; /* Empêche le zoom/scroll natif */
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    cursor: default;
    box-sizing: border-box;
}

body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    overscroll-behavior: none;
    background: #050505;
    color: #fff;
    height: 100vh;
    width: 100vw;
}

/* Effet CRT (Scanlines) */
body::after {
    content: " ";
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
    z-index: 200;
    background-size: 100% 2px, 3px 100%;
    pointer-events: none;
}

#tetris {
    height: 100vh;
    margin-bottom: 0px;
    /* Centrage absolu pour gérer le resize JS */
    display: flex;
    justify-content: center;
    align-items: center;
    height: calc(100vh - 200px);
    width: 100vw;
    position: relative;
    z-index: 10;
    margin-bottom: 200px;
}

#tetrisCanvas {
    background: rgba(0, 0, 0, 0.85);
    box-shadow: 0 0 20px #00adef, inset 0 0 20px rgba(0, 0, 0, 0.5);
    border: 2px solid #00adef;
    border-radius: 4px;
    /* La taille est gérée par JS maintenant */
}

/* UI Overlay styling */
.hud-container {
    position: absolute;
    top: 20px;
    right: 20px; /* Positionné en haut à droite */
    width: 120px;
    text-align: right;
    display: none;
    pointer-events: none;
}

@media (min-width: 800px) {
    .hud-container {
        display: block;
        right: calc(50% - 363px); /* Ajustement par rapport au centre */
        top: 50%;
        transform: translateY(-50%);
    }
}

.hud-box {
    margin-bottom: 20px;
    background: rgba(0, 173, 239, 0.1);
    border: 1px solid #00adef;
    padding: 15px;
    box-shadow: 0 0 10px rgba(0, 173, 239, 0.2);
    text-align: center;
    backdrop-filter: blur(4px);
}

.hud-label {
    font-size: 10px;
    color: #00adef;
    margin-bottom: 8px;
    text-transform: uppercase;
}

.hud-value {
    font-size: 16px;
    color: #fff;
    text-shadow: 0 0 5px #fff;
}

#mobile-score {
    position: fixed;
    top: 10px;
    left: 0;
    width: 100%;
    text-align: center;
    pointer-events: none;
    z-index: 150;
    text-shadow: 0 0 5px #000;
    background: rgba(0,0,0,0.5);
    padding: 5px 0;
}

/* Background Animation */
#background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    background: radial-gradient(circle at center, #1a0b2e 0%, #000000 100%);
}

.bg-grid {
    position: absolute;
    width: 200vw;
    height: 200vh;
    left: -50%;
    top: -50%;
    background-image: 
        linear-gradient(rgba(0, 173, 239, 0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 173, 239, 0.1) 1px, transparent 1px);
    background-size: 40px 40px;
    transform: perspective(500px) rotateX(60deg);
    animation: gridMove 20s linear infinite;
}

@keyframes gridMove {
    0% { transform: perspective(500px) rotateX(60deg) translateY(0); }
    100% { transform: perspective(500px) rotateX(60deg) translateY(40px); }
}

/* Controls - Optimisés pour la fiabilité */
#mobile-controls {
    display: flex;
    justify-content: space-between;
    position: fixed;
    bottom: 20px; /* Plus bas pour maximiser l'écran */
    z-index: 150;
    left: 10px;
    right: 10px;
    width: calc(100% - 20px);
    height: 140px; /* Hauteur réservée */
    pointer-events: none; /* Laisse passer les clics au travers des vides */
}

#left-controls {
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    gap: 15px;
    align-items: center;
    pointer-events: auto;
    padding-bottom: 10px;
}

#right-controls {
    display: flex;
    align-items: flex-end;
    justify-content: flex-end;
    padding-bottom: 25px;
    pointer-events: auto;
}

.control-row {
    display: flex;
    justify-content: center;
    gap: 20px;
}

/* Styles des boutons améliorés */
button {
    width: 70px;
    height: 70px;
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255, 255, 255, 0.15);
    color: rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    font-size: 24px;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
    touch-action: manipulation;
    transition: transform 0.05s, background 0.05s;
    outline: none;
    -webkit-tap-highlight-color: transparent;
}

button:active, button.active {
    background: rgba(0, 173, 239, 0.3);
    transform: scale(0.95) translateY(2px);
    box-shadow: 0 0 10px rgba(0, 173, 239, 0.5);
    border-color: #00adef;
    color: #fff;
}

#rotate-btn {
    width: 90px !important;
    height: 90px !important;
    background: rgba(255, 50, 50, 0.15);
    border-color: rgba(255, 50, 50, 0.3);
    font-size: 14px;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
}

#rotate-btn:active, #rotate-btn.active {
    background: rgba(255, 0, 50, 0.4);
    box-shadow: 0 0 20px rgba(255, 0, 50, 0.6);
    border-color: #ff0032;
}

/* Cache les contrôles sur Desktop */
@media (min-width: 1024px) {
    #tetris {
        height: 100vh;
        margin-bottom: 0px;
    }
    #mobile-controls, #mobile-score {
        display: none;
    }
}
</style>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
</head>
<body>

<div id="background">
    <div class="bg-grid"></div>
</div>

<div id="mobile-score">
    <span id="m-score">0</span> <span style="font-size:10px;color:#aaa;margin-left:10px">HI: <span id="m-high">0</span></span>
</div>

<div id="tetris">
    <!-- HUD Desktop -->
    <div class="hud-container">
        <div class="hud-box">
            <div class="hud-label">SCORE</div>
            <div class="hud-value" id="d-score">0</div>
        </div>
        <div class="hud-box">
            <div class="hud-label">HIGH</div>
            <div class="hud-value" id="d-high">0</div>
        </div>
        <div class="hud-box">
            <div class="hud-label">LINES</div>
            <div class="hud-value" id="d-lines">0</div>
        </div>
    </div>
    
    <canvas id="tetrisCanvas"></canvas>
    
    <!-- Contrôles Mobiles -->
    <div id="mobile-controls">
        <div id="left-controls">
            <div class="control-row">
                <button id="left-btn">←</button>
                <button id="right-btn">→</button>
            </div>
            <button id="down-btn">↓</button>
        </div>
        <div id="right-controls">
            <button id="rotate-btn">ROT</button>
        </div>
    </div>
</div>

<script>
// --- CONFIGURATION ---
let SCORE = 0;
let LINES = 0;
let HIGHSCORE = localStorage.getItem('tetris_highscore') ? parseInt(localStorage.getItem('tetris_highscore')) : 0;

const canvas = document.getElementById("tetrisCanvas");
const ctx = canvas.getContext("2d");
const rows = 20;
const cols = 10;
let boxSize = 30; // Sera recalculé dynamiquement

let dropSpeed = 500;
let lastTime = 0;
let dropCounter = 0;
let isPaused = false;

// Colors with Glow definitions
const PIECES = [
    { shape: [[1, 1], [1, 1]], color: "#FFE135", glow: "#FFD700" }, // O - Yellow
    { shape: [[1, 1, 1, 1]], color: "#00E5FF", glow: "#00BCD4" }, // I - Cyan
    { shape: [[0, 1, 0], [1, 1, 1]], color: "#D500F9", glow: "#AA00FF" }, // T - Purple
    { shape: [[1, 1, 0], [0, 1, 1]], color: "#00E676", glow: "#00C853" }, // S - Green
    { shape: [[0, 1, 1], [1, 1, 0]], color: "#FF1744", glow: "#D50000" }, // Z - Red
    { shape: [[1, 0, 0], [1, 1, 1]], color: "#2979FF", glow: "#2962FF" }, // J - Blue
    { shape: [[0, 0, 1], [1, 1, 1]], color: "#FF9100", glow: "#FF6D00" }  // L - Orange
];

let tetrisBoard = Array.from({ length: rows }, () => Array(cols).fill(0));
let currentPiece = randomPiece();
let particles = [];
let shakeX = 0;
let shakeY = 0;
let shakeDuration = 0;

// --- RESIZE LOGIC (FULLSCREEN ADAPTATION) ---
function handleResize() {
    const isMobile = window.innerWidth < 1024;
    
    // Calcul de l'espace disponible
    let availableHeight = window.innerHeight;
    let availableWidth = window.innerWidth;

    // Sur mobile, on réserve de la place en bas pour les boutons
    if (isMobile) {
        availableHeight -= 180; // Espace pour les contrôles
        availableHeight -= 40;  // Espace pour le score en haut
        availableWidth -= 20;   // Marges latérales
    } else {
        availableHeight -= 40;  // Marges minimales desktop
        availableWidth -= 300;  // Place pour le HUD latéral
    }

    // Calcul de la taille de bloc idéale pour ne pas déborder
    const sizeByHeight = Math.floor(availableHeight / rows);
    const sizeByWidth = Math.floor(availableWidth / cols);
    
    // On prend la plus petite des deux pour que tout rentre
    boxSize = Math.min(sizeByHeight, sizeByWidth);
    
    // Minimum size pour lisibilité, maximum pour ne pas être absurde sur 4k
    boxSize = Math.max(15, Math.min(boxSize, 45)); 

    canvas.width = boxSize * cols;
    canvas.height = boxSize * rows;
    
    // Redessiner immédiatement
    drawBoard();
}

// Appeler au chargement et au redimensionnement
window.addEventListener('resize', handleResize);
handleResize(); // Initial call


// --- CORE FUNCTIONS ---

function updateScore() {
    document.getElementById("d-score").innerText = SCORE;
    document.getElementById("d-high").innerText = HIGHSCORE;
    document.getElementById("d-lines").innerText = LINES;
    document.getElementById("m-score").innerText = SCORE;
    document.getElementById("m-high").innerText = HIGHSCORE;

    if (SCORE > HIGHSCORE) {
        HIGHSCORE = SCORE;
        localStorage.setItem('tetris_highscore', HIGHSCORE);
    }
}

function randomPiece() {
    const r = Math.floor(Math.random() * PIECES.length);
    const piece = {
        shape: PIECES[r].shape,
        color: PIECES[r].color,
        glow: PIECES[r].glow,
        x: Math.floor(cols / 2) - 1,
        y: 0
    };
    return piece;
}

function drawBlock(x, y, color, glow, isGhost = false) {
    const px = x * boxSize;
    const py = y * boxSize;

    if (isGhost) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.3;
        ctx.strokeRect(px + 2, py + 2, boxSize - 4, boxSize - 4);
        ctx.globalAlpha = 1.0;
        return;
    }

    ctx.shadowBlur = 15;
    ctx.shadowColor = glow;
    
    ctx.fillStyle = color;
    ctx.fillRect(px + 1, py + 1, boxSize - 2, boxSize - 2);
    
    ctx.shadowBlur = 0; 
    ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
    ctx.fillRect(px + 2, py + 2, boxSize - 4, boxSize / 2 - 2);
}

function drawBoard() {
    // Background fade
    ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Screen Shake
    ctx.save();
    if (shakeDuration > 0) {
        shakeX = (Math.random() - 0.5) * 10;
        shakeY = (Math.random() - 0.5) * 10;
        shakeDuration--;
    } else {
        shakeX = 0;
        shakeY = 0;
    }
    ctx.translate(shakeX, shakeY);

    // Grid
    ctx.strokeStyle = "rgba(255, 255, 255, 0.03)";
    ctx.lineWidth = 1;
    for (let i = 0; i <= cols; i++) {
        ctx.beginPath();
        ctx.moveTo(i * boxSize, 0);
        ctx.lineTo(i * boxSize, canvas.height);
        ctx.stroke();
    }
    for (let i = 0; i <= rows; i++) {
        ctx.beginPath();
        ctx.moveTo(0, i * boxSize);
        ctx.lineTo(canvas.width, i * boxSize);
        ctx.stroke();
    }

    // Frozen Blocks
    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            if (tetrisBoard[y][x]) {
                const cell = tetrisBoard[y][x];
                drawBlock(x, y, cell.color, cell.glow);
            }
        }
    }

    // Ghost Piece
    let ghost = Object.assign({}, currentPiece);
    while (!collision(ghost, tetrisBoard)) {
        ghost.y++;
    }
    ghost.y--; 
    for (let y = 0; y < ghost.shape.length; y++) {
        for (let x = 0; x < ghost.shape[y].length; x++) {
            if (ghost.shape[y][x]) {
                drawBlock(ghost.x + x, ghost.y + y, ghost.color, ghost.glow, true);
            }
        }
    }

    // Current Piece
    for (let y = 0; y < currentPiece.shape.length; y++) {
        for (let x = 0; x < currentPiece.shape[y].length; x++) {
            if (currentPiece.shape[y][x]) {
                drawBlock(currentPiece.x + x, currentPiece.y + y, currentPiece.color, currentPiece.glow);
            }
        }
    }

    // Particles
    drawParticles();

    ctx.restore();
}

// --- PARTICLES ---
function spawnExplosion(x, y, color) {
    for (let i = 0; i < 8; i++) {
        particles.push({
            x: x * boxSize + boxSize / 2,
            y: y * boxSize + boxSize / 2,
            vx: (Math.random() - 0.5) * 8,
            vy: (Math.random() - 0.5) * 8,
            life: 1.0,
            color: color,
            size: Math.random() * 4 + 2
        });
    }
}

function spawnDropEffect(piece) {
    shakeDuration = 2;
    for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) {
                if(piece.y + y + 1 >= rows || (tetrisBoard[piece.y+y+1] && tetrisBoard[piece.y+y+1][piece.x+x])) {
                     spawnExplosion(piece.x + x, piece.y + y, piece.color);
                }
            }
        }
    }
}

function drawParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.2;
        p.life -= 0.03;

        if (p.life <= 0) {
            particles.splice(i, 1);
            continue;
        }

        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
    }
    ctx.globalAlpha = 1.0;
}

// --- LOGIC ---
function collision(piece, board) {
    for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) {
                let boardX = piece.x + x;
                let boardY = piece.y + y;
                if (boardX < 0 || boardX >= cols || boardY >= rows || (boardY >= 0 && board[boardY][boardX])) {
                    return true;
                }
            }
        }
    }
    return false;
}

function rotatePiece(piece) {
    const rows = piece.shape.length;
    const cols = piece.shape[0].length;
    let newShape = [];
    for (let x = 0; x < cols; x++) {
        newShape[x] = [];
        for (let y = 0; y < rows; y++) {
            newShape[x][rows - y - 1] = piece.shape[y][x];
        }
    }
    return newShape;
}

function freezePiece() {
    for (let y = 0; y < currentPiece.shape.length; y++) {
        for (let x = 0; x < currentPiece.shape[y].length; x++) {
            if (currentPiece.shape[y][x]) {
                tetrisBoard[currentPiece.y + y][currentPiece.x + x] = { 
                    color: currentPiece.color,
                    glow: currentPiece.glow 
                };
            }
        }
    }
    
    spawnDropEffect(currentPiece);
    removeLines();
    
    currentPiece = randomPiece();
    if (collision(currentPiece, tetrisBoard)) {
        // Game Over
        SCORE = 0;
        LINES = 0;
        tetrisBoard = Array.from({ length: rows }, () => Array(cols).fill(0));
    }
    updateScore();
}

function removeLines() {
    let linesCleared = 0;
    
    for (let y = rows - 1; y >= 0; y--) {
        if (tetrisBoard[y].every(cell => cell !== 0)) {
            for(let x = 0; x < cols; x++) {
                spawnExplosion(x, y, "#FFF");
            }
            
            tetrisBoard.splice(y, 1);
            tetrisBoard.unshift(Array(cols).fill(0));
            linesCleared++;
            y++; 
        }
    }
    
    if (linesCleared > 0) {
        shakeDuration = 10 + (linesCleared * 2);
        LINES += linesCleared;
        const points = [0, 40, 100, 300, 1200];
        SCORE += points[linesCleared] * (Math.floor(LINES / 10) + 1);
        dropSpeed = Math.max(100, 500 - (Math.floor(LINES / 5) * 40));
    }
}

function update(time = 0) {
    const deltaTime = time - lastTime;
    lastTime = time;

    dropCounter += deltaTime;
    if (dropCounter > dropSpeed) {
        currentPiece.y++;
        if (collision(currentPiece, tetrisBoard)) {
            currentPiece.y--;
            freezePiece();
        }
        dropCounter = 0;
    }

    drawBoard();
    requestAnimationFrame(update);
}

function move(dir) {
    currentPiece.x += dir;
    if (collision(currentPiece, tetrisBoard)) {
        currentPiece.x -= dir;
    }
}

function drop() {
    currentPiece.y++;
    if (collision(currentPiece, tetrisBoard)) {
        currentPiece.y--;
        freezePiece();
    }
    dropCounter = 0;
}

function rotate() {
    const prevShape = currentPiece.shape;
    currentPiece.shape = rotatePiece(currentPiece);
    if (collision(currentPiece, tetrisBoard)) {
        currentPiece.x++; 
        if (collision(currentPiece, tetrisBoard)) {
            currentPiece.x -= 2; 
            if (collision(currentPiece, tetrisBoard)) {
                currentPiece.x++; 
                currentPiece.shape = prevShape;
            }
        }
    }
}

document.addEventListener("keydown", event => {
    if (event.keyCode === 37 || event.key === "ArrowLeft") move(-1);
    else if (event.keyCode === 39 || event.key === "ArrowRight") move(1);
    else if (event.keyCode === 40 || event.key === "ArrowDown") drop();
    else if (event.keyCode === 38 || event.key === "ArrowUp") rotate();
});

// --- ROBUST MOBILE CONTROLS & SWIPE ---
function setupMobileControls() {
    const btnLeft = document.getElementById("left-btn");
    const btnRight = document.getElementById("right-btn");
    const btnDown = document.getElementById("down-btn");
    const btnRotate = document.getElementById("rotate-btn");

    // "Reliable" Button Logic: Instant action -> Delay -> Fast Repeat
    function attachRepeatButton(btn, action) {
        let timer = null;
        let interval = null;
        
        const start = (e) => {
            if(e.cancelable) e.preventDefault();
            btn.classList.add("active");
            action(); // Immediate action
            
            // Wait 200ms before starting repeat
            timer = setTimeout(() => {
                interval = setInterval(action, 90); // Fast repeat
            }, 200);
        };
        
        const end = (e) => {
            if(e.cancelable) e.preventDefault();
            btn.classList.remove("active");
            clearTimeout(timer);
            clearInterval(interval);
        };

        btn.addEventListener("touchstart", start, { passive: false });
        btn.addEventListener("touchend", end);
        btn.addEventListener("touchcancel", end);
        
        // Mouse fallback
        btn.addEventListener("mousedown", start);
        btn.addEventListener("mouseup", end);
        btn.addEventListener("mouseleave", end);
    }

    attachRepeatButton(btnLeft, () => move(-1));
    attachRepeatButton(btnRight, () => move(1));
    attachRepeatButton(btnDown, drop);
    
    // Rotate is just a tap, no repeat needed
    const rotateAction = (e) => {
        if(e.cancelable) e.preventDefault();
        btnRotate.classList.add("active");
        rotate();
        setTimeout(() => btnRotate.classList.remove("active"), 100);
    };
    btnRotate.addEventListener("touchstart", rotateAction, { passive: false });
    btnRotate.addEventListener("mousedown", rotateAction);


    // --- SWIPE & TAP ON CANVAS ---
    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    
    canvas.addEventListener('touchstart', function(e) {
        e.preventDefault();
        touchStartX = e.changedTouches[0].pageX;
        touchStartY = e.changedTouches[0].pageY;
        touchStartTime = new Date().getTime();
    }, {passive: false});

    canvas.addEventListener('touchmove', function(e) {
        e.preventDefault(); // Prevent scroll
    }, {passive: false});

    canvas.addEventListener('touchend', function(e) {
        e.preventDefault();
        let touchEndX = e.changedTouches[0].pageX;
        let touchEndY = e.changedTouches[0].pageY;
        let elapsedTime = new Date().getTime() - touchStartTime;

        let diffX = touchEndX - touchStartX;
        let diffY = touchEndY - touchStartY;

        // Si le mouvement est très petit et rapide = TAP = ROTATE
        if (Math.abs(diffX) < 10 && Math.abs(diffY) < 10 && elapsedTime < 300) {
            rotate();
        } 
        // Sinon c'est un SWIPE
        else {
            if (Math.abs(diffX) > Math.abs(diffY)) {
                // Horizontal
                if (Math.abs(diffX) > 30) { // Threshold
                    if (diffX > 0) move(1);
                    else move(-1);
                }
            } else {
                // Vertical
                if (Math.abs(diffY) > 30) {
                    if (diffY > 0) drop(); // Swipe Down
                    // Swipe Up unused usually, or maybe hard drop?
                }
            }
        }
    }, {passive: false});
}

// Init
setupMobileControls();
updateScore();
update();

// Music
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let isPlaying = false;

// Tableau complet des notes [Note, Division de mesure]
const fullMelody = [
    // --- PARTIE A (Thème principal) ---
    ['E5', 4], ['B4', 8], ['C5', 8], ['D5', 4], ['C5', 8], ['B4', 8],
    ['A4', 4], ['A4', 8], ['C5', 8], ['E5', 4], ['D5', 8], ['C5', 8],
    ['B4', 4], ['B4', 8], ['C5', 8], ['D5', 4], ['E5', 4],
    ['C5', 4], ['A4', 4], ['A4', 2],
    ['D5', 4], ['F5', 8], ['A5', 4], ['G5', 8], ['F5', 8],
    ['E5', 4], ['C5', 8], ['E5', 4], ['D5', 8], ['C5', 8],
    ['B4', 4], ['B4', 8], ['C5', 8], ['D5', 4], ['E5', 4],
    ['C5', 4], ['A4', 4], ['A4', 2],

    // --- PARTIE B (Le Pont) ---
    ['E4', 2], ['C4', 2],
    ['D4', 2], ['B3', 2],
    ['C4', 2], ['A3', 2],
    ['Ab3', 2], ['B3', 4], [null, 4],
    ['E4', 2], ['C4', 2],
    ['D4', 2], ['B3', 2],
    ['C4', 4], ['E4', 4], ['A4', 2],
    ['Ab4', 2], [null, 2],

    // --- PARTIE C (Final Chromatique / Accélération) ---
    ['E5', 4], ['B4', 8], ['C5', 8], ['D5', 4], ['C5', 8], ['B4', 8],
    ['A4', 4], ['A4', 8], ['C5', 8], ['E5', 4], ['D5', 8], ['C5', 8],
    ['B4', 4], ['B4', 8], ['C5', 8], ['D5', 4], ['E5', 4],
    ['C5', 4], ['A4', 4], ['A4', 4], [null, 4]
];

const frequencies = {
    'Ab3': 207.65, 'A3': 220.00, 'B3': 246.94, 'C4': 261.63, 'D4': 293.66, 'E4': 329.63,
    'Ab4': 415.30, 'A4': 440.00, 'B4': 493.88, 'C5': 523.25, 'D5': 587.33, 'E5': 659.25,
    'F5': 698.46, 'G5': 783.99, 'A5': 880.00
};

function playNote(freq, duration, startTime) {
    if (!freq) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = 'square'; // Timbre 8-bit classique
    osc.frequency.value = freq;

    gain.gain.setValueAtTime(0.1, startTime);
    gain.gain.exponentialRampToValueAtTime(0.0001, startTime + duration - 0.03);

    osc.connect(gain);
    gain.connect(audioCtx.destination);

    osc.start(startTime);
    osc.stop(startTime + duration);
}

function playKorobeiniki() {
    let tempo = 140; // Rythme de jeu soutenu
    let currentTime = audioCtx.currentTime;
    let totalDuration = 0;

    fullMelody.forEach(([note, division]) => {
        let duration = (60 / tempo) * (4 / division);
        if (note) playNote(frequencies[note], duration, currentTime);
        currentTime += duration;
        totalDuration += duration;
    });

    // Boucle infinie
    setTimeout(playKorobeiniki, totalDuration * 1000);
}

document.addEventListener('click', () => {
    if (!isPlaying) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        playKorobeiniki();
        isPlaying = true;
    }
}, { once: true });


</script>
</body>
</html>
